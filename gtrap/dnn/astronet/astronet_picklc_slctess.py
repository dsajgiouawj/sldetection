import numpy as np
import matplotlib.pyplot as plt
import gtrap.read_tesstic as tesstic
from keras.models import load_model

import glob
import re
import argparse
import os
import sys

def makearr(flist):
    lab=[]
    X=[]
    Xw=[]
    info=[]
#    ginfo=[]
    for fn in flist:
        try:
            d=np.load(fn,allow_pickle=True)
            lab.append(d["arr_0"][0])
            Xtmp=d["arr_1"]
            Xtmp[Xtmp!=Xtmp]=0.0
            X.append(Xtmp+1.0)
            
            Xwtmp=d["arr_2"]
            Xwtmp[Xwtmp!=Xwtmp]=0.0        
            Xw.append(Xwtmp+1.0)
            info.append(d["arr_3"])
        except:
            print("UNAVAILABLE FILE=",fn)
            sys.exit()
#        ginfo.append(d["arr_4"])
    lab=np.array(lab).astype(np.int32)
    X=np.array(X).reshape(np.shape(X)[0],np.shape(X)[1],1)
    Xw=np.array(Xw).reshape(np.shape(Xw)[0],np.shape(Xw)[1],1)
    info=np.array(info)
#    ginfo=np.array(ginfo)
    
    return lab,X,Xw,info#,ginfo

#precision
def Precision(y_true, y_pred):
    true_positives = backend.sum(backend.cast(backend.greater(backend.clip(y_true * y_pred, 0, 1), 0.20), 'float32'))
    pred_positives = backend.sum(backend.cast(backend.greater(backend.clip(y_pred, 0, 1), 0.20), 'float32'))

    precision = true_positives / (pred_positives + backend.epsilon())
    return precision

#recall
def Recall(y_true, y_pred):
    true_positives = backend.sum(backend.cast(backend.greater(backend.clip(y_true * y_pred, 0, 1), 0.20), 'float32'))
    poss_positives = backend.sum(backend.cast(backend.greater(backend.clip(y_true, 0, 1), 0.20), 'float32'))

    recall = true_positives / (poss_positives + backend.epsilon())
    return recall

#f-measure
def Fvalue(y_true, y_pred):
    p_val = Precision(y_true, y_pred)
    r_val = Recall(y_true, y_pred)
    f_val = 2*p_val*r_val / (p_val + r_val)

    return f_val



if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='CNN prediction for picklc')
    parser.add_argument('-d', nargs=1, default=["/home/kawahara/gtrap/examples/picklc_slctess/group0/1"],help='directory containing train sets generated by gtls_pick_slctess.', type=str)
    parser.add_argument('-f', nargs=1, default=["astronet.h5"],help='astronet name h5.', type=str)

    args = parser.parse_args()
    print("USE ",args.f[0])
    traindir=args.d[0]
    print(traindir[-1])
    
    flist=sorted(glob.glob(os.path.join(traindir,'*.npz')))
    print(len(flist))
#    print(flist[0:10])
    lab,X,Xw,info=makearr(flist)
    

    model = load_model(args.f[0])
    pred=model.predict([Xw,X])
    pred=pred.transpose()[0]
#    crit=0.995
    crit=0.99
    flist=np.array(flist)
    mask=(pred>crit)
    #    print(np.shape(pred))
    tic=info[mask,2]
    sector=info[mask,3]
    camera=info[mask,4]
    CCD=info[mask,5]
    T0=info[mask,6]

#    T0=ginfo[mask,1]
#    print(kic)
#    print(ginfo[mask,:])
    rate=pred[mask]
    Xm=X[mask,:,0]
    Xwm=Xw[mask,:,0]
    
    print(pred[mask])
    print("True n=",len(pred[mask]))
    ff = open("detected.dat", 'w')
    for j,f in enumerate(flist[mask]):
        ticn=str(tic[j])+"_"+str(sector[j])+"_"+str(camera[j])+"_"+str(CCD[j])
        ff.write(ticn+"\n")
    ff.close()

    for j,f in enumerate(flist[mask]):
        ticn=str(tic[j])+"_"+str(sector[j])+"_"+str(camera[j])+"_"+str(CCD[j])
        try:
            hdf="/pike/pipeline/TIC3/tess_"+ticn+".h5"
            time, flux, q, cno, ra, dec, tic1, sector1, camera1, CCD1, cnts=tesstic.read_tesstic(hdf)        
        except:
            hdf="/pike/pipeline/step3/tess_"+ticn+".h5"
            time, flux, q, cno, ra, dec, tic1, sector1, camera1, CCD1, cnts=tesstic.read_tesstic(hdf)        
        #print(ticn)
        fig = plt.figure()
        ax = fig.add_subplot(211)
        ax.plot(Xm[j,:],".")
#        plt.title("KIC="+str(kic[j])+" T0="+str(T0[j])+" rate="+str(rate[j]))
#        ax = fig.add_subplot(211)
        plt.title(ticn)
#        ax.plot(Xwm[j,:],".")
        ax = fig.add_subplot(212)
        mask=(q==0)
        plt.axvline(T0[j],color="red",ls="dashed",alpha=0.5)
        ax.plot(time[mask],flux[mask],".")
        plt.savefig("pred"+ticn+".png")

